## 代码规范

### 常见命名法

` 驼峰命名法（CamelCase）`
: 不同单词之间没有分隔符，大小写混合区分不同单词。 

    ` 大驼峰命名法（UpperCamelCase）`
    : 又称为帕斯卡命名法（PascalCase）：首字母大写。复合词的首字母缩写和缩略词算作一个单词:使用Uuid而不是UUID，使用Usize而不是USize,使用Stdin而不是StdIn。

    ` 小驼峰命名法（lowerCamelCase）`
    : 将大驼峰命名法，首字母改为小写。

`蛇形命名法（snake_case）`
: 使用下划线分隔不同单词。

    ` 小蛇式（snake_case）`
    : 首字缩写和缩略词用全小写，如：is_xid_start。除了最后一部分，其它部分的词语都不能由单个字母组成： btree_map 而不是 b_tree_map，PI_2 而不是 PI2。
      通常用于声明数据库字段名。此外，URL 参数一般也使用 snake_case。在某些 API 设计中，如果查询参数的键与值直接放在 URL 中，可以使用 snake_case。例如 https://api.example.com/users?user_name=john_doe。
    
    ` 大蛇式（SCREAMING_SNAKE_CASE）`
    : 所有单词都大写。通常用于宏定义和命名常量。

` 烤串命名法（Kebab-Case）`
: 使用中划线连接多个单词，从而形成一个字符串。由于这种连接方式形象地类似于烤肉串

    `小烤串式（kebab-case）`
    : 所有单词小写，使用中划线连接多个单词。小烤串式在 Lisp 编程语言中经常被用到，所以有时也叫做 lisp-case。URL 路径中经常使用小烤串式。例如 www.blog.com/cool-article-1
      这是一种很好的、干净的、可读的单词组合方式。我们在 K8S 的资源配置文件中也会看到 kebab-case。此外，在 CSS 中，所有属性名称和大多数关键字值也主要采用 kebab-case 格式。

    ` 大烤串式（SCREAMING-KEBAB-CASE）`
    : 所有单词大写，使用中划线连接多个单词。大烤串式主要用于突出强调被命名的对象，古老的 Cobol 编程语言中经常使用，所以有时也被称为 COBOL-CASE。

    ` HTTP头式`
    : 如果所有单词首字母都大写，称之为 HTTP 头式（HTTP-Header-Case）。 因为 HTTP 头部字段的命名使用这种方式，所以称之为 HTTP 头式，如 Content-Type、User-Agent 等。

`匈牙利命名法（Hungarian notation）`
: ~~这是早期的规范，已废弃。变量名按：属性+类型+对象描述的顺序组合起来。按照在微软中的使用场景，分为匈牙利应用命名法和匈牙利系统命名法。 
  匈牙利应用命名法指在微软软件产品中使用的匈牙利命名法，比如 Word、Excel 和其他应用程序。 匈牙利系统命名法是指在 Windows 操作系统中使用的匈牙利命名法，因 Windows API 而被大家熟知。
  匈牙利系统命名法在匈牙利应用命名法之后出现，二者的区别主要在于前缀的目的不同。~~

### Rust 中的常见命名法与规范

Rust变量名中可以包含字母、数字和下划线，必须以字母或下划线开头，区分大小写。

函数体需要用花括号包裹，一般左花括号与函数声明置于同一行并以空格分隔。

Rust 缩进风格为 4 个空格，而不是 1 个水平制表符。Rust 代码中的函数和变量名使用 snake case 规范风格。

词序应保持一致。动词-宾语-错误的词序。例如 ParseAddrError，而不是 AddrParseError。

| 类型           | 命名法    | 例子                                                                                                  |
|--------------|--------|-----------------------------------------------------------------------------------------------------|
| 常量           | 大蛇形命名法 | NAME                                                                                                |
| 结构体、 Trait   | 大驼峰命名法 | struct FirstName \{ name: String\}                                                                  |
| 复合数据类型       | 蛇形命名法  | tup、array                                                                                           |
| 文件名、变量、函数、方法 | 蛇形命名法  | file_name.rs、main.rs                                                                                |
| Crate        | 蛇形命名法  | actix-web，Cargo默认会把连字符“-”转换成下划线“_”。<br/>不建议以“-rs”，“_rs”，“-rust”为后缀来命名 Crate。<br/>Cargo 会强制性的将此后缀去掉。 |
| feature      | 蛇形命名法  | 不要包含没有任何实际意义的词语，例如 use-derive 。<br/>应直接将特性命名为 derive。                                               |
| 宏            | 蛇形命名法  | println!                                                                                            |

Rust 开发了一个叫做 rustfmt 的自动格式化工具，能够将用户编写的代码自动调整为一种标准风格。Rust中已经包含了该工具。详细使用参见命令手册：rustfmt --help

### 临时转换命名遵循 as_、to_、into_ 的约定

| 前缀    | 代价   | 所有权                                |                           |
|-------|------|------------------------------------|---------------------------|
| as_   | 零成本  | borrowed -> borrowed               | 都是借用，且零成本                 |
| to_   | 开销很大 | borrowed -> borrowed               | 都是借用，但开销大                 |
| to_   | 开销很大 | borrowed -> owned (non-Copy types) |
| to_   | 开销很大 | owned -> owned (Copy types)        |
| into_ | 不确定  | owned -> owned (non-Copy types)    | 会消耗（‌转移所有权）‌调用者，‌并返回一个新的值 |

### 获取器（Getter）

除了少数例外情况外,在Rust代码中不使用"get_"前缀来命名获取器（getter）。
get 的命名仅在存在单个明显可通过 getter 合理获取的对象时使用。例如,Cell::get 用于访问 Cell 的内容。因为getter和conversion之间的区别可能是微妙的,而且并不总是明确的。

对于需要进行运行时验证(如边界检查)的getter,可以考虑添加不安全的_unchecked变体。

### 集合迭代器（Iterator）

集合上产生迭代器的方法遵循 iter、iter_mut、into_iter(C-ITER)的命名规则，迭代器类型的命名与生成它们的方法匹配。


## 表达式与语句

## 函数

## 类型系统（type system）

为什么存在类型？

在底层的硬件机器中，代码和数据都是0和1，类型首要的作用是区分是代码还是数据。不同类型执行的方式不同，执行方式错误可引发严重错误。

类型：一种数据的分类，定义了允许取值的集合（通常还包括数据可执行的操作、数据的意义）。

例如：布尔值类型取值为 true 和 false ；Int16 值类型表示值介于-32768 到+32767 之间的有符号整数集合。

类型系统：一组规则，为编程语言的元素分配和实施类型。这些元素可以是变量、表达式、函数和其他高级结构。

例如：声明定义该元素是会是存放字符串、数字数组、函数、等；或者像 JavaScript 中使用 let，在运行时候会判断元素是什么类型；或者由类型系统隐式的判断该元素的类型。

可确定大小类型

胖指针(fat pointer，又译宽指针)：DST -切片或特征对象的引用和原始指针。字面意思比正常我们理解指针要"宽"，其实本质上就是一个胖指针所占用的空间不再是通常的一个指针，而是用16个字节或者更多字节，包含了动态大小类型地址信息和携带了长度信息的指针，&str就是胖指针。宽指针在rust编程语言中应用广泛。例如trait、slice内部都是由宽指针实现。一个指针（实际数据的内存地址和）+一个数据长度,长度为两个指针大小。

ZST，不需要任何内存表示的类型，比如单元类型和单元结构体,大小都是零。

### 数据类型

堆与堆栈

为了说明堆与堆栈，必须引入编译时与运行时两个概念。编译和运行其实是程序的两种时态。

栈的特点就是满足那些可以提前确定的编译时内存需求，并且程序员可以不去关心栈上内存的分配与释放，这些都是由编译器完成的工作。

堆的特点则是满足运行时的内存需求，灵活性强，但是分配与释放都需要程序员人为管理。

编译时（Compile Time）

一些信息是程序运行之前就可以确定了，对应编译时。一般来说，用栈来分配编译时就可以确定的内存需求。

运行时（Runtime）

另一类信息是程序真正运行起来才能确定的，对应运行时。堆则用来解决那些运行时才能确定的内存需求，其中最典型的就是字符串，由于字符串往往是由网络或者磁盘读出的，因此编译时无法确定其具体需求，这种情况下一般要通过堆分配内存。堆上的内存分配是操作系统malloc（全称是memory allocation，动态内存分配）负责的。

字符串（String）

以字符串s1为例，有三个元素分别是ptr（指向堆上实际字符串value的指针）、capacity（容量）、len（字符串长度）。三个元素全部都存在栈上，而实际字符串的值则存在堆上。
!!! question "Sting的真实内存布局存疑"
    cap属性与ptr是相邻的,而非之前广为流传的图示中所说len与ptr相邻。详见： [从内存布局上看，Rust的胖指针到底胖在栈上还是堆上？](https://blog.csdn.net/BEYONDMA/article/details/118460702 "一篇 Sting 类型内存布局研究")但我没有实际测试过，

image("字符串指针.png")

指针：即存放内存地址的变量，16位机器的代码时,指针占2个字节。32位机器的代码时,指针占4个字节。64位机器的代码时,指针占8个字节。即便指针变量是指向地址用的,但是编译器也会分配一块内存地址来存储指针变量。即&p拥有一个自己的内存地址，还有一个变量p的地址值。

never类型
